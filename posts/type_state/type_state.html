<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-08-18 Sun 15:25 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="author" content="Zlef" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgffb7a02">1. Introduction</a>
<ul>
<li><a href="#orge5d78f9">1.1. Attribution</a></li>
<li><a href="#org345726d">1.2. Goals</a></li>
</ul>
</li>
<li><a href="#orgdd0646f">2. Create an Iterator Decorator</a></li>
<li><a href="#org7aef730">3. Attaching constructors to other types</a></li>
<li><a href="#orgd7ec31a">4. Type State</a></li>
<li><a href="#orgdfb6cae">5. Attaching method to specific type states</a></li>
<li><a href="#org703a984">6. More functions for specific type states</a></li>
<li><a href="#org9011b76">7. Encoding my example</a></li>
<li><a href="#org1c4d6e6">8. Closing thoughts</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgffb7a02" class="outline-2">
<h2 id="orgffb7a02"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orge5d78f9" class="outline-3">
<h3 id="orge5d78f9"><span class="section-number-3">1.1.</span> Attribution</h3>
<div class="outline-text-3" id="text-1-1">
<p>
This is a learning exercise to understand the contents of <a href="https://www.youtube.com/watch?v=bnnacleqg6k">this Strange Loop video</a>. This explanation is a poor version of the video.
</p>
</div>
</div>

<div id="outline-container-org345726d" class="outline-3">
<h3 id="org345726d"><span class="section-number-3">1.2.</span> Goals</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Our goal is to design an API which allows us to monitor the progress through an iterator.
We should be able to monitor an iterator, even if we are traversing a derived iterator.
</p>

<p>
Example:
#+begin<sub>src</sub> rust
let iterator = (1..10);
let derived = iterator.map(|n| n + 1).map(|n| n % 4).filter(|n| *n &gt;= 2);
for item in derived {
    println!("from derived: {}", item);
}
n#+end<sub>src</sub>
</p>

<pre class="example">
from derived: 2
from derived: 3
from derived: 2
from derived: 3
from derived: 2
</pre>


<p>
Despite <code class="src src-rust">iterator</code> being used only to declare the <code class="src src-rust">derived</code> iterator, I would like to see the progress of <code class="src src-rust">iterator</code> when traversing <code class="src src-rust">derived</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdd0646f" class="outline-2">
<h2 id="orgdd0646f"><span class="section-number-2">2.</span> Create an Iterator Decorator</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">
<pre class="src src-rust" id="orgda17d24">use std::fmt::Display;

struct Verbose&lt;Iter&gt; {
    iter: Iter,
    cursor: u32
}

impl&lt;Iter&gt; Iterator for Verbose&lt;Iter&gt;
where Iter: Iterator, Iter::Item: Display {
    type Item = Iter::Item;


    fn next(&amp;mut self) -&gt; Option&lt;&lt;Self as Iterator&gt;::Item&gt; {
        if let Some(item) = self.iter.next() {
            println!("Processing {} -&gt; {}", self.cursor, item);
            self.cursor += 1;
            Some(item)
        } else {
            None
        }
    }
}
</pre>
</div>

<p>
Notice that Verbose can be defined over anything.
But, if the iter field is not itself an iterator, then the Verbose instance will not be an iterator either.
</p>

<div class="org-src-container">
<pre class="src src-rust">let nonsense_iterator = Verbose { cursor: 0, iter: 8};
nonsense_iterator.next(); // *fails*
</pre>
</div>

<p>
However, if the iter field on Iterator <b>is</b> an iterator, then the Verbose instance will be as well.
</p>

<div class="org-src-container">
<pre class="src src-rust">let it = (10..=15);
let mut v = Verbose { cursor: 0, iter: it };
v.collect::&lt;Vec&lt;_&gt;&gt;();
</pre>
</div>
</div>
</div>

<div id="outline-container-org7aef730" class="outline-2">
<h2 id="org7aef730"><span class="section-number-2">3.</span> Attaching constructors to other types</h2>
<div class="outline-text-2" id="text-3">
<p>
Here we will define a trait that'll be implemented for any Iterator type.
</p>

<div class="org-src-container">
<pre class="src src-rust" id="org3fa76dd">trait VerboseIteratorExt&lt;A&gt;: Sized {
    fn verbose(self) -&gt; Verbose&lt;Self&gt;;
}

impl&lt;A&gt; VerboseIteratorExt&lt;A&gt; for A where A: Iterator {
    fn verbose(self) -&gt; Verbose&lt;A&gt; {
        Verbose {cursor: 0, iter: self}
    }
}
</pre>
</div>

<p>
The way to read this is VerboseIteratorExt is a trait which is defined on <b>all types A</b> which implement Iterator.
Having VeboseIteratorExt defined for a type (which all iterators do) gives that type the function <code class="src src-rust">verbose</code>. When invoked, <code class="src src-rust">verbose</code> produces a Verbose instance.
</p>

<p>
So now we can call verbose on any type which implements Iterator.
</p>

<div class="org-src-container">
<pre class="src src-rust">let iterator = (300..400).verbose().next();
println!("The result of the iterator is {}", iterator.unwrap());
</pre>
</div>

<p>
But, since integers are not iterators, the following will fail to compile.
</p>

<div class="org-src-container">
<pre class="src src-rust">let integer: i32 = 8;
integer.verbose();
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd7ec31a" class="outline-2">
<h2 id="orgd7ec31a"><span class="section-number-2">4.</span> Type State</h2>
<div class="outline-text-2" id="text-4">
<p>
We would like to be able to encode different behaviors depending on the types.
</p>

<div class="org-src-container">
<pre class="src src-rust" id="org68d57eb">use std::fmt::Display;

struct Verbose&lt;Iter, Bound&gt; {
    iter: Iter,
    cursor: u32,
    bound: Bound
}

trait BoundDisplay: Sized {
    fn display&lt;I&gt;(&amp;self, t: &amp;Verbose&lt;I, Self&gt;) -&gt; String;
}

impl&lt;Iter, Bound&gt; Iterator for Verbose&lt;Iter, Bound&gt;
where Iter: Iterator, Iter::Item: Display, Bound: BoundDisplay {
    type Item = Iter::Item;

    fn next(&amp;mut self) -&gt; Option&lt;&lt;Self as Iterator&gt;::Item&gt; {
        if let Some(item) = self.iter.next() {
            println!("Processing {} -&gt; {}", self.bound.display(self), item);
            self.cursor += 1;
            Some(item)
        } else {
            None
        }
    }
}
</pre>
</div>

<p>
The way to read this is:
Verbose can be defined over <b>any types Iter and Bound</b> (including nonsense types like unit, bool, etc).
Any particular Verbose is only iterable if its iter field is iterable and its bound field implements BoundDisplay.
</p>

<p>
Now we need to implement a few instances of BoundDisplay and see what we can produce.
</p>

<div class="org-src-container">
<pre class="src src-rust" id="orgbd61f44">struct Finite { maximum: usize }
struct Infinite;

impl BoundDisplay for Finite { // Only reasonable on finite iterators
    fn display&lt;I&gt;(&amp;self, t: &amp;Verbose&lt;I, Self&gt;) -&gt; String {
        format!("{}/{}", t.cursor, self.maximum)
    }
}

impl BoundDisplay for Infinite { // Reasonable on finite and infinite iterators
    fn display&lt;I&gt;(&amp;self, t: &amp;Verbose&lt;I, Self&gt;) -&gt; String {
        format!("{}", t.cursor)
    }
}
</pre>
</div>

<p>
We have two components which define different ways to display the bound of an iterator. One which is appropriate for finite and infinite iterators and one which is only appropriate for finite iterators.
</p>

<div class="org-src-container">
<pre class="src src-rust">let infinite = Verbose { iter: (0..5), cursor: 0, bound: Infinite };
infinite.collect::&lt;Vec&lt;_&gt;&gt;();

let finite = Verbose { iter: (0..15), cursor: 0, bound: Finite { maximum : 800 } };
finite.collect::&lt;Vec&lt;_&gt;&gt;();
</pre>
</div>

<p>
There are a few things wrong here.
</p>
<ol class="org-ol">
<li>I do not want my API users constructing Finite and Infinite. I want to give them one simple way to construct a verbose iterator and let them <b>move states</b> to change the bound types.</li>
<li>I do not want my API to <b>be capable of</b> expressing lies. Presently, the maximum field of the Finite bound has no relationship to the actual length of the iterator.</li>
</ol>
</div>
</div>

<div id="outline-container-orgdfb6cae" class="outline-2">
<h2 id="orgdfb6cae"><span class="section-number-2">5.</span> Attaching method to specific type states</h2>
<div class="outline-text-2" id="text-5">
<p>
Lets add our <code class="src src-rust">verbose</code> syntax from earlier, along with some methods for changing between these two states.
</p>

<div class="org-src-container">
<pre class="src src-rust" id="orge073f1a">trait VerboseIteratorExt&lt;A&gt;: Sized {
    fn verbose(self) -&gt; Verbose&lt;Self, Infinite&gt;;
}

impl&lt;A&gt; VerboseIteratorExt&lt;A&gt; for A where A: Iterator {
    fn verbose(self) -&gt; Verbose&lt;Self, Infinite&gt; {
        Verbose { cursor: 0, iter: self, bound: Infinite }
    }
}

impl&lt;Iter&gt; Verbose&lt;Iter, Infinite&gt; where Iter: ExactSizeIterator {
    fn finite(self) -&gt; Verbose&lt;Iter, Finite&gt; {
        Verbose {bound: Finite {maximum: self.iter.len()}, cursor: self.cursor, iter: self.iter }
    }
}

impl&lt;Iter&gt; Verbose&lt;Iter, Finite&gt; where Iter: Iterator {
    fn infinite(self) -&gt; Verbose&lt;Iter, Infinite&gt; {
        Verbose {bound: Infinite, cursor: self.cursor, iter: self.iter }
    }
}
</pre>
</div>

<p>
So now we're able to construct Verbose with syntax attached to iterators and then move between the two type states.
</p>

<div class="org-src-container">
<pre class="src src-rust">let mut iterator = (0..10).verbose();
iterator.next();

let mut iterator = iterator.finite();
iterator.next();

let mut iterator = (0..).verbose();
iterator.next();
</pre>
</div>

<p>
And, importantly, I am disallowed from expressing a Finite Verbose when my iterator is infinite (because it will not implement <code class="src src-rust">ExactSizeIterator</code>).
</p>

<div class="org-src-container">
<pre class="src src-rust">let mut iterator = (0..).verbose().finite(); // *fails*
</pre>
</div>
</div>
</div>

<div id="outline-container-org703a984" class="outline-2">
<h2 id="org703a984"><span class="section-number-2">6.</span> More functions for specific type states</h2>
<div class="outline-text-2" id="text-6">
<p>
Using the techniques given above, I can also attach methods to only Finite/Infinite Verbose structs. Here are a few use cases for doing so:
</p>
<ol class="org-ol">
<li>Overriding the <code class="src src-rust">"Processing"</code> string.</li>
<li>Attaching more formatting for only one variant.</li>
<li>Attaching more complicated behavior for both/one variant such as structuring the output for Tracing.</li>
</ol>
</div>
</div>

<div id="outline-container-org9011b76" class="outline-2">
<h2 id="org9011b76"><span class="section-number-2">7.</span> Encoding my example</h2>
<div class="outline-text-2" id="text-7">
<p>
I am now able to express my original example.
</p>
<div class="org-src-container">
<pre class="src src-rust">let iterator = (1..10);

// NEW
let iterator = iterator.verbose();

let derived = iterator.map(|n| n + 1).map(|n| n % 4).filter(|n| *n &gt;= 2);
for item in derived {
    println!("from derived: {}", item);
}
</pre>
</div>

<p>
I have made my base iterator verbose and so, even though I am traversing the derived iterator, I see my progress through the base iterator. I even see progress for elements which are <b>filtered out</b> of the derived iterator. 
</p>
</div>
</div>

<div id="outline-container-org1c4d6e6" class="outline-2">
<h2 id="org1c4d6e6"><span class="section-number-2">8.</span> Closing thoughts</h2>
<div class="outline-text-2" id="text-8">
<p>
This document was produced in Emacs using org-mode. The source for this document can be found on my github page.
I recommend opening this document's source in Emacs with org-mode for better syntax highlighting.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Zlef</p>
<p class="date">Created: 2024-08-18 Sun 15:25</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
